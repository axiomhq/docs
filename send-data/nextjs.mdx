---
title: "Send data from Next.js app to Axiom"
description: "This page explains how to send data from your Next.js app to Axiom using the next-axiom library."
overview: "React framework for production-grade applications"
sidebarTitle: Next.js
tags:
  [
    "js",
    "axiom documentation",
    "documentation",
    "axiom",
    "guide",
    "logs",
    "nextjs",
    "next.js",
    "next",
    "next-axiom",
    "@axiomhq/nextjs",
    "javascript",
  ]
isPopular: true
popularityOrder: 9
logoId: "nextJs"
---

Next.js is a popular open-source JavaScript framework built on top of React, developed by Vercel. It’s used by a wide range of companies and organizations, from startups to large enterprises, due to its performance benefits and developer-friendly features.

To send data from your Next.js app to Axiom, choose one of the following options:

- [Axiom Vercel app](/apps/vercel)
- [next-axiom library](https://github.com/axiomhq/next-axiom)
- [Axiom Next.js Public Preview](/send-data/nextjs.mdx#)

The choice between these options depends on your individual requirements:

- The two options can collect different event types. 
  | Event type | Axiom Vercel app | next-axiom library | Axiom Next.js Public Preview | 
  | --- | --- | --- | --- | 
  | Application logs | Yes | Yes | Yes | 
  | Web Vitals | No | Yes | Yes | 
  | HTTP logs | Yes | Soon | Yes | 
  | Build logs | Yes | No | No |
  | Tracing | Yes | No | Yes | 
- If you already use Vercel for deployments, the Axiom Vercel app can be easier to integrate into your existing experience.
- The cost of these options can differ widely depending on the volume of data you transfer. The Axiom Vercel app depends on Vercel Log Drains, a feature that’s only available on paid plans. For more information, see [the blog post on the changes to Vercel Log Drains](https://axiom.co/blog/changes-to-vercel-log-drains).

For information on the Axiom Vercel app and migrating from the Vercel app to the next-axiom library, see [Axiom Vercel app](/apps/vercel).

The rest of this page explains how to send data from your Next.js app to Axiom using the next-axiom library.

## Prerequisites

- [Create an Axiom account](https://app.axiom.co/).
- [Create a dataset in Axiom](/reference/datasets) where you send your data.
- [Create an API token in Axiom](/reference/tokens) with permissions to ingest data to the dataset.
- [A new or existing Next.js app](https://nextjs.org/).

## Install next-axiom

1. In your terminal, go to the root folder of your Next.js app, and then run `npm install --save next-axiom` to install the latest version of next-axiom.
2. Add the following environment variables to your Next.js app:
   - `NEXT_PUBLIC_AXIOM_DATASET` is the name of the Axiom dataset where you want to send data.
   - `NEXT_PUBLIC_AXIOM_TOKEN` is the Axiom API token you have generated.
3. In the `next.config.ts` file, wrap your Next.js configuration in `withAxiom`:

```js
const { withAxiom } = require("next-axiom");

module.exports = withAxiom({
  // Your existing configuration.
});
```

## Capture traffic requests

To capture traffic requests, create a `middleware.ts` file in the root folder of your Next.js app:

```ts
import { Logger } from 'next-axiom'
import { NextResponse } from 'next/server'
import type { NextFetchEvent, NextRequest } from 'next/server'

export async function middleware(request: NextRequest, event: NextFetchEvent) {
    const logger = new Logger({ source: 'middleware' }); // traffic, request
    logger.middleware(request)

    event.waitUntil(logger.flush())
    return NextResponse.next()

// For more information, see Matching Paths below
export const config = {
}
```

## Web Vitals

To send Web Vitals to Axiom, add the `AxiomWebVitals` component from next-axiom to the `app/layout.tsx` file:

```ts
import { AxiomWebVitals } from "next-axiom";

export default function RootLayout() {
  return (
    <html>
      ...
      <AxiomWebVitals />
      <div>...</div>
    </html>
  );
}
```

Web Vitals are only sent from production deployments.

## Logs

Send logs to Axiom from different parts of your app. Each log function call takes a message and an optional `fields` object.

```ts
log.debug("Login attempt", { user: "j_doe", status: "success" }); // Results in {"message": "Login attempt", "fields": {"user": "j_doe", "status": "success"}}
log.info("Payment completed", { userID: "123", amount: "25USD" });
log.warn("API rate limit exceeded", {
  endpoint: "/users/1",
  rateLimitRemaining: 0,
});
log.error("System Error", { code: "500", message: "Internal server error" });
```

### Route handlers

Wrap your route handlers in `withAxiom` to add a logger to your request and log exceptions automatically:

```ts
import { withAxiom, AxiomRequest } from "next-axiom";

export const GET = withAxiom((req: AxiomRequest) => {
  req.log.info("Login function called");

  // You can create intermediate loggers
  const log = req.log.with({ scope: "user" });
  log.info("User logged in", { userId: 42 });

  return NextResponse.json({ hello: "world" });
});
```

### Client components

To send logs from client components, add `useLogger` from next-axiom to your component:

```ts
"use client";
import { useLogger } from "next-axiom";

export default function ClientComponent() {
  const log = useLogger();
  log.debug("User logged in", { userId: 42 });
  return <h1>Logged in</h1>;
}
```

### Server components

To send logs from server components, add `Logger` from next-axiom to your component, and call flush before returning:

```ts
import { Logger } from "next-axiom";

export default async function ServerComponent() {
  const log = new Logger();
  log.info("User logged in", { userId: 42 });

  // ...

  await log.flush();
  return <h1>Logged in</h1>;
}
```

### Log levels

The log level defines the lowest level of logs sent to Axiom. Choose one of the following levels (from lowest to highest):

- `debug` is the default setting. It means that you send all logs to Axiom.
- `info`
- `warn`
- `error` means that you only send the highest-level logs to Axiom.
- `off` means that you don’t send any logs to Axiom.

For example, to send all logs except for debug logs to Axiom:

```sh
export NEXT_PUBLIC_AXIOM_LOG_LEVEL=info
```

## Capture errors

To capture routing errors, use the [error handling mechanism of Next.js](https://nextjs.org/docs/app/building-your-application/routing/error-handling):

1. Go to the `app` folder.
2. Create an `error.tsx` file.
3. Inside your component function, add `useLogger` from next-axiom to send the error to Axiom. For example:

```ts
"use client";

import NavTable from "@/components/NavTable";
import { LogLevel } from "@/next-axiom/logger";
import { useLogger } from "next-axiom";
import { usePathname } from "next/navigation";

export default function ErrorPage({
  error,
}: {
  error: Error & { digest?: string };
}) {
  const pathname = usePathname();
  const log = useLogger({ source: "error.tsx" });
  let status = error.message == "Invalid URL" ? 404 : 500;

  log.logHttpRequest(
    LogLevel.error,
    error.message,
    {
      host: window.location.href,
      path: pathname,
      statusCode: status,
    },
    {
      error: error.name,
      cause: error.cause,
      stack: error.stack,
      digest: error.digest,
    }
  );

  return (
    <div className="p-8">
      Ops! An Error has occurred:{" "}
      <p className="text-red-400 px-8 py-2 text-lg">`{error.message}`</p>
      <div className="w-1/3 mt-8">
        <NavTable />
      </div>
    </div>
  );
}
```

## Extend logger

To extend the logger, use `log.with` to create an intermediate logger. For example:

```typescript
const logger = useLogger().with({ userId: 42 });
logger.info("Hi"); // will ingest { ..., "message": "Hi", "fields" { "userId": 42 }}
```

## Next.js Public Preview

## Install @axiomhq/nextjs

1. In your terminal, go to the root folder of your Next.js app, and then run:
  ```sh
  npm install --save @axiomhq/nextjs @axiomhq/logging @axiomhq/react
  ``` 
  to install the latest version of `@axiom/nextjs`, this command will also install the required dependencies.
2. Add the following environment variables to your Next.js app:
   - `AXIOM_DATASET` is the name of the Axiom dataset where you want to send data.
   - `AXIOM_TOKEN` is the Axiom API token you have generated.
   - `NEXT_PUBLIC_AXIOM_PROXY_PATH` is the Axiom proxy path you want logs from the client to be sent to, in this case we will use `/api/axiom`, but you can use any path you want.
3. Inside your project, create a folder called `axiom` inside a `lib` folder. This is where you will store configurations for Axiom.
4. Inside the newly created `axiom` folder, create a file called `server.ts`, and another file called `client.ts`.
5. In the `server.ts` file, add the following code:
   > Reference the [Axiom Logger documentation](/send-data/javascript-logging) for more information on the logger.


```ts
import { Logger, AxiomFetchTransport, ConsoleTransport } from '@axiomhq/logging';
import { createAxiomRouteHandler, serverContextFieldsFormatter } from '@axiomhq/nextjs';

export const logger = new Logger({
  transports: [
    new AxiomFetchTransport({
      dataset: process.env.AXIOM_DATASET!,
      token: process.env.AXIOM_TOKEN!,
    }),
    new ConsoleTransport({ prettyPrint: true }),
  ],
  // Adds the server execution context to the logs
  formatters: [serverContextFieldsFormatter],
});

export const withAxiom = createAxiomRouteHandler(logger);
```

> The `createAxiomRouteHandler` is a builder function that returns a wrapper for your route handlers, that will handle successful responses and errors thrown within the route handler.

5. In the `client.ts` file, add the following code:
> Reference the [Axiom React documentation](/send-data/react) for more information on the react client side helpers.

```ts
'use client';

import { Logger, ProxyTransport, ConsoleTransport } from '@axiomhq/logging';
import { createUseLogger, createWebVitalsComponent } from '@axiomhq/react';

export const logger = new Logger({
  transports: [
    new ProxyTransport({ url: process.env.NEXT_PUBLIC_AXIOM_PROXY_URL!, autoFlush: true }),
    new ConsoleTransport(),
  ],
});

const useLogger = createUseLogger(logger);
const WebVitals = createWebVitalsComponent(logger);

export { useLogger, WebVitals };
```

6. In /app/api/axiom/route.ts, add the following code:

```ts
import { logger } from "@/lib/axiom/server";
import { createProxyRouteHandler } from "@axiomhq/nextjs";

export const POST = createProxyRouteHandler(logger);
```

## Capture traffic requests

To capture traffic requests, create a `middleware.ts` file in the root folder of your Next.js app:

```ts
import { logger } from "@/lib/axiom/server";
import { transformMiddlewareRequest } from "@axiomhq/nextjs";
import { NextResponse } from "next/server";
import type { NextFetchEvent, NextRequest } from "next/server";

export async function middleware(request: NextRequest, event: NextFetchEvent) {
  logger.info(...transformMiddlewareRequest(request));

  event.waitUntil(logger.flush());
  return NextResponse.next();
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico, sitemap.xml, robots.txt (metadata files)
     */
    "/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)",
  ],
};
```
### Client components

To send logs from client components, add `useLogger` from next-axiom to your component:

```tsx
"use client";
import { useLogger } from "@/lib/axiom/client";

export default function ClientComponent() {
  const log = useLogger();
  log.debug("User logged in", { userId: 42 });
  const handleClick = () => log.info("User logged out");
  return (
    <div>
      <h1>Logged in</h1>
      <button onClick={handleClick}>Log out</button>
    </div>
  );
}
```

## Web Vitals

To capture Web Vitals, add the `WebVitals` component from next-axiom to the `app/layout.tsx` file:

```tsx
import { WebVitals } from "@/lib/axiom/client";

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <WebVitals />
      <body>{children}</body>
    </html>
  );
}
```

## Logs

Send logs to Axiom from different parts of your app. Each log function call takes a message and an optional `fields` object.

```ts
import { logger } from "@/lib/axiom/server";

log.debug("Login attempt", { user: "j_doe", status: "success" }); // Results in {"message": "Login attempt", "fields": {"user": "j_doe", "status": "success"}}
log.info("Payment completed", { userID: "123", amount: "25USD" });
log.warn("API rate limit exceeded", {
  endpoint: "/users/1",
  rateLimitRemaining: 0,
});
log.error("System Error", { code: "500", message: "Internal server error" });
```

### Route handlers

You can use the `withAxiom` function exported from the setup file in `lib/axiom/server.ts` to wrap your route handlers.

```ts
import { logger } from "@/lib/axiom/server";
import { withAxiom } from "@/lib/axiom/server";

export const GET = withAxiom(async () => {
  return new Response("Hello World!");
});
```

> For more information on how to customize the data sent to Axiom, see the [Advanced route handlers](/send-data/nextjs#advanced-route-handlers) section.

### Server components

```tsx
import { logger } from "@/lib/axiom/server";
import { after } from "next/server";

export default async function ServerComponent() {
  log.info("User logged in", { userId: 42 });

  after(() => {
    logger.flush();
  });

  return <h1>Logged in</h1>;
}
```

## Capture errors (Next 15 or later)

If you are using Next 15 or later, you can use the `onRequestError` option to capture errors in the `instrumentation.ts` file, to do so, do the following:

1. Create a `instrumentation.ts` file in the `src` or root folder of your Next.js app, depending on your configuration.
2. Add the following code:

```ts
import { logger } from "@/lib/axiom/server";
import { createOnRequestError } from "@axiomhq/nextjs";

export const onRequestError = createOnRequestError(logger);
```

You can also customize the error logging by creating a custom `onRequestError` function.

```ts
import { logger } from "@/lib/axiom/server";
import { transformOnRequestError } from "@axiomhq/nextjs";
import { Instrumentation } from "next";

export const onRequestError: Instrumentation.onRequestError = async (
  error,
  request,
  ctx
) => {
  logger.error(...transformOnRequestError(error, request, ctx));
  await logger.flush();
};
```

## Capture errors (Next 14 or earlier)

To capture routing errors, use the [error handling mechanism of Next.js](https://nextjs.org/docs/app/building-your-application/routing/error-handling):

1. Go to the `app` folder.
2. Create an `error.tsx` file.
3. Inside your component function, add `useLogger` from next-axiom to send the error to Axiom. For example:

```tsx
"use client";

import NavTable from "@/components/NavTable";
import { LogLevel } from "@axiomhq/logging";
import { useLogger } from "@/lib/axiom/client";
import { usePathname } from "next/navigation";

export default function ErrorPage({
  error,
}: {
  error: Error & { digest?: string };
}) {
  const pathname = usePathname();
  const log = useLogger({ source: "error.tsx" });
  let status = error.message == "Invalid URL" ? 404 : 500;

  log.log(LogLevel.error, error.message, {
    error: error.name,
    cause: error.cause,
    stack: error.stack,
    digest: error.digest,
    request: {
      host: window.location.href,
      path: pathname,
      statusCode: status,
    },
  });

  return (
    <div className="p-8">
      Ops! An Error has occurred:{" "}
      <p className="text-red-400 px-8 py-2 text-lg">`{error.message}`</p>
      <div className="w-1/3 mt-8">
        <NavTable />
      </div>
    </div>
  );
}
```

## Advanced customizations
## Advanced route handlers

When designing `@axiomhq/nextjs` route handlers were top of mind, as they can behave in a variety of ways, so we aimed to provide as much flexibility as possible, while retaining the simplicity and good defaults.
Here are some common customizations you might want to make to your route handlers:

### Customize data reports sent to Axiom

Within the `lib/axiom/server.ts` file, you can customize the reports sent to Axiom by using the `onError` and `onSuccess` functions that the `createAxiomRouteHandler` function accepts in the configuration object.
you can make use of the `transformRouteHandlerErrorResult` and `transformRouteHandlerSuccessResult` functions to customize the data sent to Axiom by adding fields to the report object.

```ts
import { Logger, AxiomFetchTransport, ConsoleTransport } from '@axiomhq/logging';
import { 
  createAxiomRouteHandler, 
  getLogLevelFromStatusCode, 
  serverContextFieldsFormatter, 
  transformRouteHandlerErrorResult, 
  transformRouteHandlerSuccessResult 
} from '@axiomhq/nextjs';

/* ... your logger setup ... */

export const withAxiom = createAxiomRouteHandler(logger, {
  onError: (error) => {
    if (error.error instanceof Error) {
      logger.error(error.error.message, error.error);
    }
    const [message, report] = transformRouteHandlerErrorResult(error);
    report.customField = "customValue";
    report.request.searchParams = error.req.nextUrl.searchParams;

    logger.log(getLogLevelFromStatusCode(report.statusCode), message, report);
    logger.flush();
  },
  onSuccess: (data) => {
    const [message, report] = transformRouteHandlerSuccessResult(data);
    report.customField = "customValue";
    report.request.searchParams = data.req.nextUrl.searchParams;

    logger.info(message, report);
    logger.flush();
  },
});
```

> ⚠️ CAUTION: Changing the `transformSuccessResult()` or `transformErrorResult()` functions can change the shape of your data, affecting dashboards (specially auto-generated ones) and other integrations, as a recommendation, make sure you are sending only adding fields on top of the ones returned by the default `transformSuccessResult()` or `transformErrorResult()` functions.

You can also create your own `transformSuccessResult()` or `transformErrorResult()` functions.

```ts
import { Logger, AxiomFetchTransport, ConsoleTransport } from '@axiomhq/logging';
import { 
  createAxiomRouteHandler, 
  getLogLevelFromStatusCode, 
  serverContextFieldsFormatter, 
  transformRouteHandlerErrorResult, 
  transformRouteHandlerSuccessResult 
} from '@axiomhq/nextjs';

/* ... your logger setup ... */

export const transformSuccessResult = (
  data: SuccessData
): [message: string, report: Record<string, any>] => {
  const report = {
    request: {
      type: "request",
      method: data.req.method,
      url: data.req.url,
      statusCode: data.res.status,
      durationMs: data.end - data.start,
      path: new URL(data.req.url).pathname,
      endTime: data.end,
      startTime: data.start,
    },
  };

  return [
    `${data.req.method} ${report.request.path} ${
      report.request.statusCode
    } in ${report.request.endTime - report.request.startTime}ms`,
    report,
  ];
};

export const transformRouteHandlerErrorResult = (data: ErrorData): [message: string, report: Record<string, any>] => {
  const statusCode = data.error instanceof Error ? getNextErrorStatusCode(data.error) : 500;

  const report = {
    request: {
      startTime: new Date().getTime(),
      endTime: new Date().getTime(),
      path: data.req.nextUrl.pathname ?? new URL(data.req.url).pathname,
      method: data.req.method,
      host: data.req.headers.get('host'),
      userAgent: data.req.headers.get('user-agent'),
      scheme: data.req.url.split('://')[0],
      ip: data.req.headers.get('x-forwarded-for'),
      region: getRegion(data.req),
      statusCode: statusCode,
    },
  };

  return [
    `${data.req.method} ${report.request.path} ${report.request.statusCode} in ${report.request.endTime - report.request.startTime}ms`,
    report,
  ];
};

export const withAxiom = createAxiomRouteHandler(logger, {
  onError: (error) => {
    if (error.error instanceof Error) {
      logger.error(error.error.message, error.error);
    }
    const [message, report] = transformRouteHandlerErrorResult(error);
    report.customField = "customValue";
    report.request.searchParams = error.req.nextUrl.searchParams;

    logger.log(getLogLevelFromStatusCode(report.statusCode), message, report);
    logger.flush();
  },
  onSuccess: (data) => {
    const [message, report] = transformRouteHandlerSuccessResult(data);
    report.customField = "customValue";
    report.request.searchParams = data.req.nextUrl.searchParams;

    logger.info(message, report);
    logger.flush();
  },
});
```

### Change the log level from Next.js built-in functions errors

functions like `notFound()`, `redirect()`, `forbidden()` or `unauthorized()` will throw an error and will be logged as follow:

- `redirect()` will be logged as `info`
- `forbidden()`, `notFound()` and `unauthorized()` will be logged as `warn`

You can customize this behavior by providing a custom `logLevelByStatusCode()` when logging errors from your route handler:

```ts
import { Logger, AxiomFetchTransport, ConsoleTransport, LogLevel } from '@axiomhq/logging';
import {
  createAxiomRouteHandler,
  serverContextFieldsFormatter,
  transformRouteHandlerErrorResult,
} from '@axiomhq/nextjs';

/* ... your logger setup ... */

const getLogLevelFromStatusCode = (statusCode: number) => {
  if (statusCode >= 300 && statusCode < 400) {
    return LogLevel.info;
  } else if (statusCode >= 400 && statusCode < 500) {
    return LogLevel.warn;
  }
  return LogLevel.error;
};

export const withAxiom = createAxiomRouteHandler(logger, {
  onError: (error) => {
    if (error.error instanceof Error) {
      logger.error(error.error.message, error.error);
    }
    const [message, report] = transformRouteHandlerErrorResult(error);
    report.customField = 'customValue';
    report.request.searchParams = error.req.nextUrl.searchParams;

    logger.log(getLogLevelFromStatusCode(report.statusCode), message, report);
    logger.flush();
  }
});

```

Internally the status code gets captured in the `transformErrorResult()` function using a `getNextErrorStatusCode()` function. You can also compose these functions by yourself and create your own `getNextErrorStatusCode()` function and inject the result in the `transformErrorResult()` report.

```ts
import { Logger, AxiomFetchTransport, ConsoleTransport, LogLevel } from '@axiomhq/logging';
import {
  createAxiomRouteHandler,
  serverContextFieldsFormatter,
  transformRouteHandlerErrorResult,
} from '@axiomhq/nextjs';
import { isRedirectError } from 'next/dist/client/components/redirect-error';
import { isHTTPAccessFallbackError } from 'next/dist/client/components/http-access-fallback/http-access-fallback';

export const logger = new Logger({
  transports: [
    new AxiomFetchTransport({
      dataset: process.env.AXIOM_DATASET!,
      token: process.env.AXIOM_TOKEN!,
    }),
    new ConsoleTransport({ prettyPrint: true }),
  ],
  formatters: [serverContextFieldsFormatter],
});

export const getNextErrorStatusCode = (error: Error & { digest?: string }) => {
  if (!error.digest) {
    return 500;
  }

  if (isRedirectError(error)) {
    return error.digest.split(';')[3];
  } else if (isHTTPAccessFallbackError(error)) {
    return error.digest.split(';')[1];
  }
};

const getLogLevelFromStatusCode = (statusCode: number) => {
  if (statusCode >= 300 && statusCode < 400) {
    return LogLevel.info;
  } else if (statusCode >= 400 && statusCode < 500) {
    return LogLevel.warn;
  }
  return LogLevel.error;
};

export const withAxiom = createAxiomRouteHandler(logger, {
  onError: (error) => {
    if (error.error instanceof Error) {
      logger.error(error.error.message, error.error);
    }
    const [message, report] = transformRouteHandlerErrorResult(error);

    const statusCode = error.error instanceof Error ? getNextErrorStatusCode(error.error) : 500;
    report.request.statusCode = statusCode;

    report.customField = 'customValue';
    report.request.searchParams = error.req.nextUrl.searchParams;

    logger.log(getLogLevelFromStatusCode(report.statusCode), message, report);
    logger.flush();
  },
});
```


## Server execution context

The `serverContextFieldsFormatter` function adds the server execution context to the logs, this is useful to have information about the scope where the logs were generated.

By default the `createAxiomRouteHandler` function will add a `request_id` field to the logs by making use of this server context and server context fields formatter.

### Route handlers server context

The `createAxiomRouteHandler` accepts a `store` field in the configuration object, the store can be a `Map`, an object or a function that accepts a request and context; and returns a `Map` or an object.

The fields in the store will be added to the `fields` object of the log report, you can use this for example to add a `trace_id` field to every log report within the same function execution in the route handler.

```ts
import { Logger, AxiomFetchTransport, ConsoleTransport } from '@axiomhq/logging';
import { createAxiomRouteHandler, serverContextFieldsFormatter } from '@axiomhq/nextjs';
import { NextRequest } from 'next/server';

export const logger = new Logger({
  transports: [
    new AxiomFetchTransport({
      dataset: process.env.AXIOM_DATASET!,
      token: process.env.AXIOM_TOKEN!,
    }),
    new ConsoleTransport({ prettyPrint: true }),
  ],
  formatters: [serverContextFieldsFormatter],
});

export const withAxiom = createAxiomRouteHandler(logger, {
  store: (req: NextRequest) => {
    return {
      request_id: crypto.randomUUID(),
      trace_id: req.headers.get('x-trace-id'),
    };
  },
});
```

### Sever context on arbitrary functions

You can also add the server context to any function that runs in the server, like server actions, middleware, server components, etc.

```ts
"use server";
import { runWithServerContext } from "@axiomhq/nextjs";

export const serverAction = () =>
  runWithServerContext({ request_id: crypto.randomUUID() }, () => {
    return "Hello World";
  });

```

```ts
// middleware.ts  
import { runWithServerContext } from '@axiomhq/nextjs';

export const middleware = (req: NextRequest) => 
  runWithServerContext({ trace_id: req.headers.get('x-trace-id') }, () => {
    // trace_id will be added to the log fields
    logger.info(...transformMiddlewareRequest(request));

    // trace_id will also be added to the log fields
    log.info("Hello from middleware");

    event.waitUntil(logger.flush());
    return NextResponse.next();
  });
```


