---
title: 'OpenTelemetry using Java'
description: 'This guide explains how to configure a Java app using the Java OpenTelemetry SDK to send telemetry data to Axiom.'
sidebarTitle: Java Using OTel
tags:
    ['guides', 'java']
---

OpenTelemetry provides a unified approach to collecting telemetry data from your Java applications. This guide demonstrates how to configure OpenTelemetry in a Java app to send telemetry data to Axiom using the OpenTelemetry SDK.

## Prerequisites

To configure OpenTelemetry in a Java app for sending telemetry data to Axiom, certain prerequisites are necessary. These include:

- Java: Java Development Kit (JDK) version 11 or newer.
- Java app: Use your own app written in Java, or you can start with the provided `DiceRollerApp.java` sample.
- Maven: We'll use Maven as our build tool in this guide.
- Create an Axiom account.
- **Create a dataset in Axiom** where you'll send your data.
- **Create an API token in Axiom** with permissions to create, read, update, and delete datasets.

## Project Setup

To create a Java project from the terminal using Maven, follow these steps:

**Maven:**

- First, make sure Maven is installed on your system. You can check by running `mvn -v` in your terminal.
- To create a new Java project, use the Maven archetype command:
    
    ```arduino
    
    mvn archetype:generate -DgroupId=com.example -DartifactId=MyProject -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
    ```
    

This command will create a new project in a directory named `MyProject` with a standard directory structure. 

## Core app (`DiceRollerApp.java`)

`DiceRollerApp.java` is the core of the application. It simulates rolling a dice and demonstrates the usage of OpenTelemetry for tracing. The app includes two methods: one for a simple dice roll and another that demonstrates the usage of span links to establish relationships between spans across different traces.

Create this file in the `src/main/java/com/example` directory: 

```bash
package com.example;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;

import java.util.Random;

public class DiceRollerApp {
    private static final Tracer tracer;

    static {
        OpenTelemetry openTelemetry = OtelConfiguration.initializeOpenTelemetry();
        tracer = openTelemetry.getTracer(DiceRollerApp.class.getName());
    }

    public static void main(String[] args) {
        rollDice();
        rollDiceWithLink();
    }

    private static void rollDice() {
        Span span = tracer.spanBuilder("rollDice").startSpan();
        try (Scope scope = span.makeCurrent()) {
            int roll = 1 + new Random().nextInt(6);
            System.out.println("Rolled a dice: " + roll);
        } finally {
            span.end();
        }
    }

    private static void rollDiceWithLink() {
        Span parentSpan = tracer.spanBuilder("rollWithLink").startSpan();
        try (Scope parentScope = parentSpan.makeCurrent()) {
            Span childSpan = tracer.spanBuilder("rolldice")
                    .addLink(parentSpan.getSpanContext())
                    .startSpan();
            try (Scope childScope = childSpan.makeCurrent()) {
                int roll = 1 + new Random().nextInt(6);
                System.out.println("Dice roll result (with link): " + roll);
            } finally {
                childSpan.end();
            }
        } finally {
            parentSpan.end();
        }
    }
}
```

## OpenTelemetry configuration (`OtelConfiguration.java`)

`OtelConfiguration.java` sets up the OpenTelemetry SDK and configures the exporter to send data to Axiom. It initializes the tracer provider, sets up the Axiom exporter, and configures the resource attributes.

Create this file in the `src/main/java/com/example` directory:

```bash

package com.example;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.exporter.otlp.http.trace.OtlpHttpSpanExporter;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import io.opentelemetry.sdk.trace.SdkTracerProvider;
import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;

import java.util.concurrent.TimeUnit;

public class OtelConfiguration {
    private static final String SERVICE_NAME = "YOUR_SERVICE_NAME";
    private static final String SERVICE_VERSION = "YOUR_SERVICE_VERSION";
    private static final String OTLP_ENDPOINT = "https://api.axiom.co/v1/traces";
    private static final String BEARER_TOKEN = "Bearer YOUR_AXIOM_API_TOKEN";
    private static final String AXIOM_DATASET = "YOUR_AXIOM_DATASET_NAME";

    public static OpenTelemetry initializeOpenTelemetry() {
        Resource resource = Resource.getDefault()
                .merge(Resource.create(Attributes.of(
                        AttributeKey.stringKey("service.name"), SERVICE_NAME,
                        AttributeKey.stringKey("service.version"), SERVICE_VERSION
                )));

        OtlpHttpSpanExporter spanExporter = OtlpHttpSpanExporter.builder()
                .setEndpoint(OTLP_ENDPOINT)
                .addHeader("Authorization", BEARER_TOKEN)
                .addHeader("X-Axiom-Dataset", AXIOM_DATASET)
                .build();

        SdkTracerProvider sdkTracerProvider = SdkTracerProvider.builder()
                .addSpanProcessor(BatchSpanProcessor.builder(spanExporter)
                        .setScheduleDelay(100, TimeUnit.MILLISECONDS)
                        .build())
                .setResource(resource)
                .build();

        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()
                .setTracerProvider(sdkTracerProvider)
                .buildAndRegisterGlobal();

        Runtime.getRuntime().addShutdownHook(new Thread(sdkTracerProvider::close));

        return openTelemetry;
    }
}
```

Make sure to replace `YOUR_AXIOM_API_TOKEN` with your actual Axiom API token and `YOUR_AXIOM_DATASET_NAME` with your Axiom dataset name.

## Project configuration (`pom.xml`)

The `pom.xml` file defines the project structure and dependencies for Maven. It includes the necessary OpenTelemetry libraries and configures the build process.

Update the `pom.xml` file in the root of your project directory:

```bash

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example</groupId>
  <artifactId>axiom-otel-java</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>11</maven.compiler.source>
    <maven.compiler.target>11</maven.compiler.target>
    <opentelemetry.version>1.18.0</opentelemetry.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>io.opentelemetry</groupId>
      <artifactId>opentelemetry-api</artifactId>
      <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
      <groupId>io.opentelemetry</groupId>
      <artifactId>opentelemetry-sdk</artifactId>
      <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
      <groupId>io.opentelemetry</groupId>
      <artifactId>opentelemetry-exporter-otlp</artifactId>
      <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-netty-shaded</artifactId>
      <version>1.42.1</version>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.13.2</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.8.1</version>
        <configuration>
          <source>11</source>
          <target>11</target>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>3.0.0-M5</version>
        <configuration>
          <testFailureIgnore>true</testFailureIgnore>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-shade-plugin</artifactId>
        <version>3.2.4</version>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>shade</goal>
            </goals>
            <configuration>
              <transformers>
                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                  <mainClass>com.example.DiceRollerApp</mainClass>
                </transformer>
              </transformers>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
```

## Running the instrumented app

To run your Java app with OpenTelemetry instrumentation, follow these steps:

1. Clean the project and download dependencies:

```bash
mvn clean
```

1. Compile the code:

```bash
mvn compile
```

1. Package the application:

```bash
mvn package
```

1. Run the application:

```bash
java -jar target/axiom-otel-java-1.0-SNAPSHOT.jar
```

The application will execute the `rollDice()` and `rollDiceWithLink()` methods, generating telemetry data that will be sent to Axiom.

## Observe the telemetry data in Axiom

As you run your app, traces will be collected and exported to Axiom. You can monitor and analyze your app's performance and behavior in the Axiom dashboard.

To view your traces:

1. Log in to your Axiom account.
2. Navigate to the dataset you specified in the `OtelConfiguration.java` file.
3. Use the query interface to search and filter your traces

## Dynamic OpenTelemetry traces dashboard

Axiom provides a dynamic dashboard for visualizing and analyzing your OpenTelemetry traces. This dashboard offers insights into the performance and behavior of your app.

To access the dashboard:

1. In your Axiom account, go to the dashboards section.
2. Look for the OpenTelemetry traces dashboard or create a new one.
3. Customize the dashboard to show the event data and visualizations most relevant to your app. 

## Send data from an existing Java project

### Manual instrumentation

Manual instrumentation gives you fine-grained control over what parts of your application are traced and what information is included in the traces. It requires adding OpenTelemetry-specific code to your application.

1. Set up OpenTelemetry:  

Create a configuration class to initialize OpenTelemetry with necessary settings, exporters, and span processors.

```java
// OtelConfiguration.java
package com.example;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;
import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporter;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.trace.SdkTracerProvider;
import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;

public class OtelConfiguration {
    public static OpenTelemetry initializeOpenTelemetry() {
        OtlpGrpcSpanExporter spanExporter = OtlpGrpcSpanExporter.builder()
            .setEndpoint("https://api.axiom.co/v1/traces")
            .addHeader("Authorization", "Bearer YOUR_AXIOM_API_TOKEN")
            .addHeader("X-Axiom-Dataset", "YOUR_AXIOM_DATASET_NAME")
            .build();

        SdkTracerProvider tracerProvider = SdkTracerProvider.builder()
            .addSpanProcessor(BatchSpanProcessor.builder(spanExporter).build())
            .build();

        return OpenTelemetrySdk.builder()
            .setTracerProvider(tracerProvider)
            .buildAndRegisterGlobal();
    }
}

```

1. Create spans 

Spans represent units of work in your application. They have a start time and duration, and can be nested.

```java
// DiceRollerApp.java
package com.example;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;

public class DiceRollerApp {
    private static final Tracer tracer;

    static {
        OpenTelemetry openTelemetry = OtelConfiguration.initializeOpenTelemetry();
        tracer = openTelemetry.getTracer("com.example.DiceRollerApp");
    }

    public static void main(String[] args) {
        try (Scope scope = tracer.spanBuilder("Main").startScopedSpan()) {
            rollDice();
        }
    }

    private static void rollDice() {
        Span span = tracer.spanBuilder("rollDice").startSpan();
        try (Scope scope = span.makeCurrent()) {
            // Simulate dice roll
            int result = new Random().nextInt(6) + 1;
            System.out.println("Rolled a dice: " + result);
        } finally {
            span.end();
        }
    }
}

```

Custom spans are manually managed to provide detailed insights into specific functions or methods within your application.

1. Annotate spans

Spans can be annotated with attributes and events to provide more context about the operation being performed.

```java
private static void rollDice() {
    Span span = tracer.spanBuilder("rollDice").startSpan();
    try (Scope scope = span.makeCurrent()) {
        int roll = 1 + new Random().nextInt(6);
        span.setAttribute("roll.value", roll);
        span.addEvent("Dice rolled");
        System.out.println("Rolled a dice: " + roll);
    } finally {
        span.end();
    }
}
```

1. Creating span links

Span links allow you to associate spans that are not in a parent-child relationship.

```java
private static void rollDiceWithLink() {
    Span parentSpan = tracer.spanBuilder("rollWithLink").startSpan();
    try (Scope parentScope = parentSpan.makeCurrent()) {
        Span childSpan = tracer.spanBuilder("rolldice")
                .addLink(parentSpan.getSpanContext())
                .startSpan();
        try (Scope childScope = childSpan.makeCurrent()) {
            int roll = 1 + new Random().nextInt(6);
            System.out.println("Dice roll result (with link): " + roll);
        } finally {
            childSpan.end();
        }
    } finally {
        parentSpan.end();
    }
}
```

### Automatic instrumentation

Automatic instrumentation simplifies the process of adding telemetry to a Java application by automatically capturing data from supported libraries and frameworks.

1. Set up dependencies: 

Ensure all necessary OpenTelemetry libraries are included in your Maven `pom.xml`.

```xml
<!-- pom.xml snippet -->
<dependencies>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-api</artifactId>
        <version>{opentelemetry_version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-sdk</artifactId>
        <version>{opentelemetry_version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry.instrumentation</groupId>
        <artifactId>opentelemetry-instrumentation-httpclient</artifactId>
        <version>{instrumentation_version}</version>
    </dependency>
</dependencies>

```

Dependencies include the OpenTelemetry SDK and instrumentation libraries that automatically capture data from common Java libraries.

1. Auto-instrument the app:

Implement an initialization class to configure the OpenTelemetry SDK along with auto-instrumentation for frameworks used by your application.

```java
// AutoInstrumentationSetup.java
package com.example;

import io.opentelemetry.instrumentation.httpclient.HttpClientInstrumentation;
import io.opentelemetry.api.OpenTelemetry;

public class AutoInstrumentationSetup {
    public static void setup() {
        OpenTelemetry openTelemetry = OtelConfiguration.initializeOpenTelemetry();
        HttpClientInstrumentation.instrument(openTelemetry);
    }
}

```

Auto-instrumentation is initialized early in the application lifecycle to ensure all relevant activities are automatically captured. 

1. Integrate and run: 

The auto-instrumentation setup is called as your app starts:

```java
// Main.java
package com.example;

public class Main {
    public static void main(String[] args) {
        AutoInstrumentationSetup.setup();  // Initialize OpenTelemetry auto-instrumentation
        DiceRollerApp.main(args);          // Start the application logic
    }
}
```

## Reference

### List of OpenTelemetry trace fields

| Field Category | Field Name | Description |
| --- | --- | --- |
| General Trace Information |  |  |
|  | _rowId | Unique identifier for each row in the trace data. |
|  | _sysTime | System timestamp when the trace data was recorded. |
|  | _time | Timestamp when the actual event being traced occurred. |
|  | trace_id | Unique identifier for the entire trace. |
|  | span_id | Unique identifier for the span within the trace. |
|  | parent_span_id | Unique identifier for the parent span within the trace. |
| Operational Details |  |  |
|  | duration | Time taken for the operation, typically in microseconds or milliseconds. |
|  | kind | Type of span (e.g., server, internal). |
|  | name | Name of the span, often a high-level title for the operation. |
| Scope and Instrumentation |  |  |
|  | http://scope.name/ | Instrumentation scope, typically the Java package or app component, e.g., com.example.DiceRollerApp. |
| Service Attributes |  |  |
|  | http://service.name/ | Name of the service generating the trace, e.g., axiom-java-otel. |
|  | service.version | Version of the service generating the trace, e.g., 0.1.0. |
| Telemetry SDK Attributes |  |  |
|  | telemetry.sdk.language | Programming language of the SDK used for telemetry, typically 'java'. |
|  | http://telemetry.sdk.name/ | Name of the telemetry SDK, e.g., opentelemetry. |
|  | telemetry.sdk.version | Version of the telemetry SDK used in the tracing setup, e.g., 1.18.0. |

### List of imported libraries

The Java implementation of OpenTelemetry uses the following key libraries:

## `io.opentelemetry:opentelemetry-api`

This package provides the core OpenTelemetry API for Java. It defines the interfaces and classes that developers use to instrument their applications manually. This includes the `Tracer`, `Span`, and `Context` classes, which are fundamental to creating and managing traces in your application. The API is designed to be stable and consistent, allowing developers to instrument their code without tying it to a specific implementation.

## `io.opentelemetry:opentelemetry-sdk`

The opentelemetry-sdk package is the reference implementation of the OpenTelemetry API for Java. It provides the actual functionality behind the API interfaces, including span creation, context propagation, and resource management. This SDK is highly configurable and extensible, allowing developers to customize how telemetry data is collected, processed, and exported. It's the core component that brings OpenTelemetry to life in a Java application.

## `io.opentelemetry:opentelemetry-exporter-otlp`

This package provides an exporter that sends telemetry data using the OpenTelemetry Protocol (OTLP). OTLP is the standard protocol for transmitting telemetry data in the OpenTelemetry ecosystem. This exporter allows Java applications to send their collected traces, metrics, and logs to any backend that supports OTLP, such as Axiom. The use of OTLP ensures broad compatibility and a standardized way of transmitting telemetry data across different systems and platforms.

## `io.opentelemetry:opentelemetry-sdk-extension-autoconfigure`

This extension package provides auto-configuration capabilities for the OpenTelemetry SDK. It allows developers to configure the SDK using environment variables or system properties, making it easier to set up and deploy OpenTelemetry-instrumented applications in different environments. This is particularly useful for containerized applications or those running in cloud environments where configuration through environment variables is common.

## `io.opentelemetry:opentelemetry-sdk-trace`

This package is part of the OpenTelemetry SDK and focuses specifically on tracing functionality. It includes important classes like `SdkTracerProvider` and `BatchSpanProcessor`. The `SdkTracerProvider` is responsible for creating and managing tracers, while the `BatchSpanProcessor` efficiently processes and exports spans in batches, similar to its Node.js counterpart. This batching mechanism helps in optimizing the performance of trace data export in OpenTelemetry-instrumented Java applications.

## `io.opentelemetry:opentelemetry-sdk-common`

This package provides common functionality used across different parts of the OpenTelemetry SDK. It includes utilities for working with attributes, resources, and other shared concepts in OpenTelemetry. This package helps ensure consistency across the SDK and simplifies the implementation of cross-cutting concerns in telemetry data collection and processing.