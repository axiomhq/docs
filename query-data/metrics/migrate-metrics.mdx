---
title: Migrate PromQL queries to Axiom
description: This page explains how to migrate your PromQL queries to Axiom.
sidebarTitle: Migrate
---

## Differences between AxQL and PromQL

While AxQL and PromQL are both designed for querying metrics data, they differ in fundamental ways that impact how queries are written and interpreted. This section outlines the key differences to help you adapt PromQL workflows when migrating to Axiom.

### Richer type system

Prometheus treats all label values as strings, which often leads users to rely heavily on regular expressions for filtering. AxQL, by contrast, supports a broader and more expressive type system, including native types like numbers, booleans, and timestamps. This means you can write cleaner, type-aware queries and avoid the pitfalls of string-only comparisons.

For OpenTelemetry (OTel) data, this difference means that AxQL preserves source types, enabling more accurate and efficient filtering and aggregation.

### Labels versus fields

PromQL is optimized for a sparse label space and performs poorly with high-cardinality label sets. This design limits how many dimensions can be encoded as labels.

AxQL doesn’t impose the same restrictions. It encourages richer, high-cardinality data ingestion, allowing you to store and query more attributes per event without performance degradation.

Additionally, PromQL users often use enrichment queries simulate dimensional joins and join label values from one series into another. AxQL doesn’t currently support this pattern because it diverges from OpenTelemetry semantics, which emphasize event-based modeling over metric enrichment.

### Histogram behavior

Histogram support differs significantly. In PromQL, histogram queries typically yield one time series per bucket or a single quantile series depending on the function.

AxQL allows histogram operations that can output multiple series in a single query, providing greater flexibility for analyzing distributions or rendering percentile summaries directly.

### Regular expression syntax

In PromQL, regular expressions are written as string literals. This requires escaping special characters using double quotes and backslashes, which can be error-prone.

AxQL treats regular expressions as a first-class type. They’re written directly without string escaping, making them easier to use and less ambiguous.

<Tip>
Regex is a native type in AxQL. Denote regex using slash (`/`) instead of quotation marks (`'` or `"`).

In regex, escape slash (`/`), but don’t escape quotation marks (`'` or `"`).
</Tip>

## Examples

### Average over time

<CodeGroup>
```kusto Prometheus example
avg_over_time(
   (
      max(
          axiomdb_transport_ingest_pressure\{
             time_window = "1m",
              service =~ "axiomdb-[a-f]"
          \}
       ) <bool 0.4
   )[7d:]
)
````

```kusto AxQL equivalent
test-with-minus.com:axiomdb_transport_ingest_pressure as snot
| where time_window == "1m"
| where service == /axiomdb-[a-f]/
| group using max
| as cookie
| map < 0.4
| align to 7d using avg
| as cake
```
</CodeGroup>

### Multiply each value by 100

<CodeGroup>
```kusto Prometheus example
http_request_duration_seconds_count{} * 100
````

```kusto AxQL equivalent
test:axiom_http_request_duration_seconds_count
| map * 100
```
</CodeGroup>

### Calculate average error rate

Calculate the average error rate per 5-minute windows on a set of HTTP endpoints.

<CodeGroup>
```kusto Prometheus example
sum(rate(http_request_duration_count{           container=~"ingest|api|login", path=~".*(ingest|(?:v1/(traces|logs))).*", code!~"[1234].."}[5m]))
/
sum(rate(http_request_duration_count{container=~"ingest|api|login", path=~".*(ingest|(?:v1/(traces|logs))).*"}[5m]))
````

```kusto AxQL equivalent
{ 
  test:http_request_duration_count
  | filter container =~ /ingest|api|login/
  | filter path =~ /.*(ingest|(?:v1\/(traces|logs))).*/
  | filter code >= 500 
  | map rate
  | align to 5m using avg
  | group using sum;
  test:http_request_duration_count
  | filter container =~ /ingest|api|login/
  | filter path =~ /.*(ingest|(?:v1\/(traces|logs))).*/
  | map rate
  | align to 5m using avg
  | group using sum
} compute using / as error_rate
```
</CodeGroup>

### Calculate CPU saturation

Calculate CPU saturation (actual over requested) of each service.

<CodeGroup>
```kusto Prometheus example
max(
  label_replace(
  (sum(node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate{namespace=~"(axiom|cloud).*",pod=~"ingest-.*"}) by (pod)
    /
    sum(cluster:namespace:pod_cpu:active:kube_pod_container_resource_requests{namespace=~"(axiom|cloud).*", pod=~"ingest-.*", resource="cpu"}) by (pod)),
  "service", "$1", "pod", "(.+)-.+-.+")
) by (service)
````

```kusto AxQL equivalent
{
    test:container_cpu_usage_seconds_total
    | filter namespace =~ /(axiom|cloud).*/
    | filter pod =~ /ingest-.*/
    | group by pod using sum;
    test:kube_pod_container_resource_requests
    | filter namespace =~ /(axiom|cloud).*/
    | filter pod =~ /ingest-.*/
    | filter resource == "cpu"
    | group by pod using sum;
} compute by pod using / as cpu_usage
| replace service = pod ~ s/(.+)-.+-.+/$1/
| group by service using max
```
</CodeGroup>

### Calculate running average

Calculate the running average relation between two metrics.

<CodeGroup>
```kusto Prometheus example
avg_over_time(metric_a[5m]) / avg_over_time(metric_b[1h])
````

```kusto AxQL equivalent
{
    test:metric_a
    | align avg(5m, 1m);
    test:metric_a
    | align avg(1h, 1m)
} join using / as avg_over_time
```
</CodeGroup>

### Calculate rate

Calculate rate of HTTP requests by method, path and http response code.

<CodeGroup>
```kusto Prometheus example
sum by (method, path, code) (
      rate(
          http_requests_total{
              path=~".*(ingest|(?:v1/(traces|logs))).*",
              code=~"[123].."
          }[5m]
      )
  )
````

```kusto AxQL equivalent
test:http_requests_total
| filter path =~ /.*(ingest|(?:v1\/(traces|logs))).*/
| filter code =~ /[123]../
| map rate
| align to 5m using avg
| group by method, path, code using sum
```
</CodeGroup>

### Calculate Service Level Objectives (SLO)

Calculate SLO with the goal of max 40% ingest pressure over the running average of 1 hour over the past 7 days.

<CodeGroup>
```kusto Prometheus example
avg_over_time(
  (max(
    transport_ingest_pressure{
      time_window = "1m",
      service =~ "db-[a-f]"
    }
  ) <bool 0.4)[7d:]
)
````

```kusto AxQL equivalent
test:transport_ingest_pressure
| filter time_window == "1m"
| filter service =~ /db-[a-f]/
| group using max
| map < 0.4
| align avg(7d, 1h)
```
</CodeGroup>

### Calculate error rate SLO

Calculate the error rate SLO as a running average over the past seven days, with a goal of 80% success rate.

<CodeGroup>
```kusto Prometheus example
avg_over_time(
    ((
        sum(rate(http_requests_total{container=~"ingest|api|login", path=~".*(ingest|(?:v1/(traces|logs))).*", code!~"[1234].."}[1h]))
        /
        sum(rate(http_requests_total{container=~"ingest|api|login", path=~".*(ingest|(?:v1/(traces|logs))).*"}[1h]))
    ) <bool 0.2)[7d:]
)
````

```kusto AxQL equivalent
{
  test:http_requests_total
  | filter container =~ /ingest|api|login/
  | filter path =~ /.*(ingest|(?:v1\/(traces|logs))).*/ 
  | filter code < 500
  | map rate
  | align avg(1h)
  | group using sum;
  test:http_requests_total
  | filter container =~ /ingest|api|login/
  | filter path =~ /.*(ingest|(?:v1\/(traces|logs))).*/ 
  | map rate
  | align avg(1h)
  | group using sum
} join using / as error_rate
| map < 0.2
| align avg(7d, 1h)
```
</CodeGroup>
