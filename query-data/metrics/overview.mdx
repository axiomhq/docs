---
title: Metrics
description: This section explains how to work with OpenTelemetry (OTel) metrics.
sidebarTitle: Overview
---

import Prerequisites from "/snippets/standard-prerequisites.mdx"

Axiom’s dedicated MetricsDB provides a purpose-built metrics datastore that handles high-cardinality time-series data without the cost penalties and performance degradation common in traditional metrics systems. This section explains how to work with OpenTelemetry (OTel) metrics in Axiom.

<Info>
Support for OTel metrics is currently in public preview. For more information, see [Feature states](/platform-overview/roadmap#feature-states).

Axiom is confident in the quality of MetricsDB and the reliability of the data it stores. However, preview features are experimental, and Axiom doesn’t guarantee data integrity or accuracy for preview features.

During the public preview, Axiom won’t charge you for ingest or query related to metrics. Your organization has a soft limit of 100,000 active series. [Contact us](https://axiom.co/contact) to increase this limit.
</Info>

## What makes MetricsDB different

MetricsDB is engineered from the ground up to embrace dimensional complexity:

- **High-cardinality as a design principle**: Store metrics with high-cardinality tags. Where other metrics datastore penalize you with higher costs or degraded performance, MetricsDB treats high cardinality as a core capability.
- **Intentional architecture**: The storage format, query engine, and compression algorithms are specifically optimized for time-series metrics workloads. These design constraints are thoughtful trade-offs that deliver exceptional performance and cost-efficiency for real-world metrics use cases.
- **Unified observability**: Query metrics alongside logs and traces, enabling powerful correlations across all your telemetry data without switching tools or learning multiple query languages.

### MetricsDB vs EventDB

Logs and metrics are different forms of event data. It’s often possible to represent metrics as events, but a dedicated metrics datastore comes with the following benefits:

- **Efficient compression**: Instrumentation aggregates measurements on the client and sends summaries at regular intervals instead of individual events. This dramatically reduces data volume for high-frequency measurements.
- **Standardized data types**: OpenTelemetry defines a small set of metric types with clear semantics. The metric type tells you how to query the data—no guessing how to aggregate or calculate rates.
- **Faster queries**: Metrics data is stored in a format optimized for producing time series and other popular metrics visualizations. No need to process the data at query time.

### When to use MetricsDB or EventDB for metrics

If you can send metrics data to Axiom using the OTel Collector or another OTel-compatible SDK, use MetricsDB.

If you can’t use the OTel Collector or another OTel-compatible SDK, and you want to send metrics data to Axiom, use EventDB if the following are true:

- **Your metrics are gauges**: Point-in-time measurements like temperature or memory usage that don’t need rate calculations.
- **Query complexity is low**: You’re querying small quantities of data, and can afford to derive metrics at query time.
- **Low-frequency measurements**: You’re tracking metrics that occur infrequently which means the cost of storing individual events remains manageable.

EventDB provides flexible querying through APL without requiring structured metric types.

### When EventDB-based metrics become problematic

Deriving metrics from event data works well for simple use cases, but this approach doesn’t scale as your metrics workload grows:

- **High-frequency measurements**: When you need to track metrics that occur many times per second (like request counts or latency measurements), MetricsDB is a more efficient way to store data. MetricsDB aggregates these measurements on the client side, dramatically reducing storage costs.
- **High-cardinality tags**: EventDB can handle high-cardinality data, but deriving metrics from events with many unique tag combinations requires processing large volumes of data at query time. MetricsDB’s storage format is optimized for this workload, enabling fast queries even with many unique tag combinations.
- **Rate calculations and aggregations**: Calculating rates, percentiles, and other aggregations from raw events requires scanning and processing large amounts of data at query time. MetricsDB stores pre-aggregated data in a format optimized for these operations.
- **Cost efficiency**: For high-frequency metrics, the cost of storing individual events quickly exceeds the cost of storing aggregated metric data. MetricsDB’s compression and aggregation significantly reduce storage requirements.
- **Query performance**: As your metrics data grows, queries that derive metrics from events become slower and more expensive. MetricsDB queries are optimized for time-series data and maintain consistent performance as data volume increases.

If your metrics workload exhibits any of these characteristics, MetricsDB provides better performance, cost efficiency, and scalability than deriving metrics from events.

<Prerequisites />

<Note>
You must use a dedicated dataset for OTel metrics. When you create a dataset, select the type of OTel data you want to send to it. For more information, see [Create dataset](/reference/datasets#create-dataset).
</Note>

## Ingest metrics

You can ingest OTel metrics the same way you ingest logs and traces.

For more information, see [Send OpenTelemetry data to Axiom](/send-data/opentelemetry).

<Note>
The `/v1/metrics` endpoint only supports the `application/x-protobuf` content type. JSON format isn’t supported for metrics ingestion.
</Note>

## Query metrics

You can query metric data using the Axiom Console. For more information, see [Query metrics](/query-data/metrics/query-metrics).

<Frame>
<img src="/doc-assets/shots/example-metrics-query.png" alt="Example metrics query" />
</Frame>

## Dashboards and monitors

You can use OTel metrics in dashboards and monitors the same way you use logs and traces.

- Build visualizations using metrics queries.
- Set alerts on derived metrics such as error rate or latency percentiles.
- Combine multiple signals in a single panel.

For more information, see [Dashboards](/dashboards/overview) and [Monitors](/monitor-data/monitors).

<Frame caption="OTel metrics dashboard">
  <img src="/doc-assets/shots/otel-metrics-dashboard.png" alt="OTel metrics dashboard" />
</Frame>

## Design choices and constraints

MetricsDB makes intentional architectural trade-offs to optimize for the most common metrics use cases while maintaining exceptional performance at scale.

### Query scope

You can query one dataset per query.

### Supported data types

MetricsDB focuses on the core OpenTelemetry metric types that cover the vast majority of observability scenarios.

Axiom supports the following OpenTelemetry metric types:
- **Gauge**: Point-in-time measurements. For example, CPU usage or temperature.
- **Histogram**: Distribution of values with configurable buckets. For example, request latency.
- **Sum**: Sum of values. For example, request count.
- **Summary**: Summary of values. For example, request latency.

Axiom doesn’t currently support the following data types:
- Exponential histograms
- `bytes`, `kvlist`, and `array` tag value types
- Exemplar, baggage, and context data
- Nanosecond-precision timestamps

### Data model optimizations

MetricsDB applies the following transformations to improve query performance and reduce storage costs:

- **Timestamp precision**: Truncate nanosecond timestamps to second precision. MetricsDB is built for use cases where second-level granularity is sufficient, and this optimization significantly improves compression ratios and query speed.
- **Unified tag namespace**: Flatten resource, scope, and metric tags into a single namespace. This simplification makes queries more straightforward and enables faster dimensional filtering. You don’t need to remember which tags came from which scope.
- **Unit normalization**: Convert the `unit` attribute to `otel.metric.unit` for consistent handling across all metric types.
- **Histogram handling**: Assume equal-width histograms and don’t preserve histogram metadata. This trade-off supports the most common histogram analysis patterns (percentiles, distribution visualization) while reducing storage requirements.

These design choices reflect real-world metrics usage patterns. If your use case requires capabilities not currently supported, [contact Axiom](https://axiom.co/contact) to discuss your requirements. Your feedback helps shape MetricsDB’s evolution.
