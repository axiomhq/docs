---
title: Query metrics
description: This page explains how to query OpenTelemetry metrics.
---

In Axiom, you can use two query languages:
- Axiom Processing Language (APL) lets you query datasets with events, OTel logs, and OTel traces. For more information, see [Introduction to APL](/apl/introduction).
- AxQL lets you query OTel metrics. This page explains how to use AxQL.

AxQL is a metric-focused query language that combines the simplicity of APL with the expressive power of PromQL. It enables effective querying, transformation, and aggregation of metric data, supporting diverse observability use cases. It addresses the shortcomings of existing metric query languages, which are either overly complex or too rigidly tied to specific storage formats.

AxQL is highly compatible with PromQL. Existing PromQL expressions can be translated to AxQL for quick onboarding and greater flexibility. For more information, see [Migrate metrics to Axiom](/query-data/metrics/migrate-metrics).

<Info>
Support for OTel metrics is currently in public preview. For more information, see [Feature states](/platform-overview/roadmap#feature-states).
</Info>

## Limitations

The current implementation of AxQL comes with the following limitations:

- You can only query one dataset in a query.

## Concepts

- **Dataset:** A group of related metrics.
- **Metric:** One-dimensional time series data.
- **Tag:** Key-value pair identifying a series.
- **Series:** A unique combination of a metric and tag set.

## Query structure

A typical AxQL query contains the following:

1. **Source**: Defines dataset, metric, and optional time range
1. **Filter**: Applies conditions to series via tags
1. **Transformation** can be the following:
    - **Mapping:** Maps the data to a new value.
    - **Aggregation:** Aggregates the data over a given time to a single value.
    - **Grouping:** Groups the data by a set of tags, combining overlapping values.
    - **Bucketing:** A two-dimensional transformation that combines the time and tag dimension.

**Example:**

```kusto
k8s:cpu_usage[1h..]
| where namespace == "prod"
| align avg(5m)
```

This example queries the `k8s` dataset’s `cpu_usage` metric one hour before the current time. It filters results to events where `namespace` is `prod` and aggregates events over 5-minute time windows into their average value.

## Elements of queries

The following explains each element of an AxQL query.

To learn more about the language features of AxQL, see [Language features](#language-features).

### Source

Specify the dataset, the metric, and optional time bounds.

**Syntax:**

```kusto
<dataset>:<metric>[<time range>][ as <alias>]
```

- **dataset**: Name of the dataset.
- **metric**: Name of the metric.
- **time range**: Optional: The time range of the query. For more information, see [Time ranges](#time-ranges).
- **alias**: Optional: Renames the metric for later use.

**Examples:**

```kusto
k8s:cpu_usage[1h..]
k8s:cpu_usage[2h..5m]
k8s:cpu_usage["2025-03-01T13:00:00Z"..+1h] as usage
```

### Filter

Use `where` or `filter` to filter series based on tag values. `where` and `filter` are identical.

**Syntax:**

```kusto
| where <tag> <operator> <value>
```

Available operators:

- Equality: `==`, `!=`
- Comparisons: `<`, `<=`, `>`, `>=`
- Logical: `and`, `or`, `not`
{/* - Set: `in` */}

The value must be one of the [supported data types](#data-types).

**Example:**

```kusto
| where project == /.*metrics.*/ and code >= 200 and code < 300
```

### Mapping

Transform individual values or series.

Available functions:

| Function              | Description                                                      |
|-----------------------|------------------------------------------------------------------|
| `rate`                | Computes the per-second rate of change for a metric.             |
| `min(arg)`            | Returns the minimum between the argument and the value.               |
| `max(arg)`            | Returns the maximum between the argument and the value.               |
| `abs`                 | Returns the absolute value of each data point.                   |
| `fill_prev`           | Fills missing values using the previous non-null value.          |
| `fill_const(arg)`     | Fills missing values with a constant.                            |
| `+`, `-`, `*`, `/`    | Performs the respective mathematical calculation on each value.  |
|  `>`, `<`, `>=`, `<=` | Sets the value to `1.0` if the condition is true, `0` otherwise. |

**Examples for data mappings:**

```kusto
// Calculate rate per second for the metric
| map rate

// Add 5 to each value
| map  + 5

// Fill empty values with the latest value
| map fill_last

// Fill empty values with zeros
| map fill_const(0)

// Set existing values to 0 if the value is < 0.4. Else set to 1.
| map < 0.4
```

{/*
```kusto
// Transform data using a custom function from WASM
| map wasm::my_module::my_function(1, 2, 3)
```

**Examples for series mappings:**

```kusto
// Rename the metric to `cpu_usage_rate`
| as cpu_usage_rate

// Rename the tag `load` to `cpu_load`
| replace load=cpu_load

// Replace the value of `hostname` using a regular expression
TODO

// Create the new tag `core` by adding 1 to `gpu_core`
| replace core = gpu_core + 1

// Remove the tag `gpu_core`
| remove gpu_core
```
*/}

### Aggregation

Use `align` to aggregate over time windows.

**Syntax:**

```kusto
| align <aggregation_function>(<time_window>)
```

{/*
```kusto
| align <aggregation_function>(<time_window>[, <step>])
```
*/}

Available aggregation functions:

| Function | Description                           |
|----------|---------------------------------------|
| `avg`    | Averages values in each interval.     |
| `sum`    | Sums values in each interval.         |
| `min`    | Takes the minimum value per interval. |
| `max`    | Takes the maximum value per interval. |
| `count`  | Counts non-null values per interval.  |

**Examples:**

```kusto
// Calculate the average over 5-minute time windows
| align avg(5m)

// Count the data points in the last hour
| align count(1h)
```

{/*
```kusto
// Calculate the running average every minute with a lookback window of 5 minutes
| align avg(5m, 1m)

// Aggregate data using a custom function from WASM
| align wasm::my_module::my_function(30s)
```
*/}

### Grouping

Use `group by` to combine series by tags.

**Syntax:**

```kusto
| group [by <tag1>, <tag2>] using <aggregation_function>
```

If you don’t specify tags, Axiom aggregates all series into one group.

Available aggregation functions:

| Function | Description                           |
|----------|---------------------------------------|
| `avg`    | Averages values in each interval.     |
| `sum`    | Sums values in each interval.         |
| `min`    | Takes the minimum value per interval. |
| `max`    | Takes the maximum value per interval. |
| `count`  | Counts non-null values per interval.  |

**Examples:**

```kusto
// Calculate the number of series
| group using count

// Calculate the total number of nodes
| group using sum

// Group data by the `project` and `namespace` tags using the `sum` aggregation
| group by project, namespace using sum
```

{/*
// Group data by the `project` and `namespace` tags using a custom aggregation function from WASM
| group by project, namespace using wasm::my_module::my_function(1, 2, 3)
```
*/}

### Bucketing

Bucketing is a special case of grouping that combines the time and tag dimensions.

**Syntax:**

```kusto
| bucket by <tags> using <function>(<window>)
```

Available functions:

| Function          | Description                                                             |  
|-------------------|-------------------------------------------------------------------------|  
| `histogram`             | Calculates a histogram over all values in the bucket. |  
| `interpolate_histogram` | Interpolates a histogram from a histogram-type set of series.    |  

**Examples:**

```kusto
// Bucket over the `project` and `namespace` tags using the histogram aggregation
| bucket by project, namespace using histogram(5m)
```

{/*
```kusto
// Bucket over the `project` and `namespace` tags using a custom aggregation function from WASM
| bucket by project, namespace using wasm::my_module::my_function(5m)
```
*/}

## Other operations

### Compute

Combine multiple metrics in one query block.

**Syntax:**

```kusto
{
  <subquery1>;
  <subquery2>;
}
| compute <name> using <operator>
```

Available operators:

| Operator | Description                       |
|----------|-----------------------------------|
| `+`      | Adds subquery results.               |
| `-`      | Subtracts one subquery from another. |
| `*`      | Multiplies subquery results.               |
| `/`      | Divides one subquery by another.     |
| `min`    | Minimum across result series.     |
| `max`    | Maximum across result series.     |
| `avg`    | Average across result series.     |

**Example:**

```kusto
// Return the average error rate over the past 5 minutes
{
 k8s-metrics-dev:http_requests_total
 | where code >= 400
 | group by method, path using sum;
 k8s-metrics-dev:http_requests_total
 | group by method, path using sum;
}
| compute error_rate using /
| align avg(5m)
```

{/*
### Join

Pull tags from another series.

**Syntax:**

```kusto
| join <tag(s)> from <source> by <key>
```

**Example:**

```kusto
// Pull the `created_by_kind` tag from the `test` dataset’s `kube_pod_info` metric and join it with the `kube_pod_status_ready` metric using the `pod` field as the key
test:kube_pod_status_ready
| group by pod using sum;
| join created_by_kind from test:kube_pod_info by pod
```

### Format

Use `format` as the last operator in your query to format the results.

**Example:**

```kusto
// Format HTTP requests into strings like `"GET[200]: /api/v1/metrics"`
| format "{{.method}}{{.code}}: {{.path}}"
```

## Modifiers

Modifiers are declarations at the beginning of a query that can:
- Configure query settings
- Define query parameters
- Import custom functions

### Query settings

Use the `set` command to configure settings at the beginning of a query.

**Syntax:**

```kusto
set <query_settings>[=<value>];
```

Available query settings:

- `strict`: Use strict mode for production queries where it is crucial to get the correct information.
- `warn`: Define whether you want to see warning to improve your query. 
- `behavior`: Allow conversion of non-string data to string data. This is useful for cross-compiling Prometheus queries that treat everything as a string.
- `edition`: Define the edition of AxQL your query uses.

**Examples:**

```kusto
// Use strict mode
set strict;

// Warn for possible type conflicts
set warn=types;

// Warn for possible performance issues
set warn=performance;

// Warn for idiomatic issues
set warn=ideomatic;

// Allow conversion of non-string data to string data
set behaviour=regexp-string-conversion;

// Define the edition of AxQL your query uses
set edition=2025;
```

### Query parameters

Define query parameters at the beginning of a query.

**Syntax:**

```kusto
set query=<query_parameter>:<type>
```

**Example:**

```kusto
// Import the `step` query parameter with the type `relative_time`
set query=step:relative_time
```

To reference the query parameters in your query, use the dollar sign (`$`).

**Example:**

```kusto
// Calculate the running average over a one-hour window, emitting every `step`
| align avg($step, 1h)
```

### Custom functions

To import custom functions to your query, use the `wasm` command. You can import modules from WASM files you have previously uploaded to Axiom.

**Syntax:**

```kusto
set wasm=<module_name>:<file_name>
```

**Example:**

```kusto
// Import the module named `my_module` from the `ai_functions.wasm` file
set wasm=my_module:ai_functions.wasm 
```

To reference custom functions in your query, use the following syntax:

**Syntax:**

```kusto
wasm::<module_name>::<function_name>
```

**Example:**

```kusto
// Bucket over the `project` and `namespace` tags using a custom aggregation function from WASM
| bucket by project, namespace using wasm::my_module::my_function(5m)
```
*/}

## Language features

### Data types

- Strings: `"string"`
- Integers: `42`
- Floats: `3.14`
- Booleans: `true`, `false`
- Regex: `/.*metrics.*/`
{/* - Sets: `[value1, value2]` */}

### Identifier naming rules

Valid identifier names in AxQL follow these rules:

- Between 1 and 1024 characters long.
- Allowed characters:
    - Alphanumeric characters (letters and digits)
    - Underscore (`_`)
    - Space (` `)
    - Dot (`.`)

Identifier names are case-sensitive.

### Quote identifiers

Quote an identifier in your AxQL query if any of the following is true:

- The identifier name contains an unsupported character.
- The identifier name is identical to one of the reserved keywords of the APL query language. For example, `by` or `where`.

If any of the above is true, you must quote the identifier by enclosing it in backticks (`\``). For example, ``my-field``.

If none of the above is true, you don’t need to quote the identifier in your AxQL query. For example, `myfield`. In this case, quoting the identifier name is optional.

### Time ranges

**Syntax:**

```kusto
[<start>..<end>?]
```

Define time ranges with the following:

- **Start time:**: Inclusive beginning of the time range.
- **End time:** Optional, exclusive end of the time range. If you don’t specify the end time, Axiom uses the current time.

Separate the start and the end times with `..`.

Time can be defined in one of the following ways:

- Relative time. The time unit can be one of the following:
    - `ms` for milliseconds (will be rounded to seconds)
    - `s` for seconds
    - `m` for minutes
    - `h` for hours
    - `d` for days
    - `w` for weeks
    - `M` for months
    - `y` for years
    Examples: `-1h`, `+5m`
- Unix epoch timestamp in seconds. For example: `1723982394`
- An RFC3339 timestamp. For example: `2025-03-01T13:00:00Z`

**Examples:**

```kusto
// One hour ago until the current time
[1h..]

// One hour after a Unix timestamp
[1747077736092..+1h]

// One hour before a Unix timestamp
[-1h..1747077736092]

// One hour before an RFC3339 date
[-1h..2025-03-01T13:00:00Z]
```
