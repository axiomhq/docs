---
title: join
description: 'This page explains how to use the join operator in APL.'
---

The `join` operator in Axiom Processing Language (APL) combines rows from two tables based on matching values in specified columns. Use `join` to correlate data from different sources or datasets, such as linking logs to traces or enriching logs with additional metadata.

This operator is useful when you want to:

- Combine information from two datasets with shared keys.
- Analyze relationships between different types of events.
- Enrich existing data with supplementary details.

<Note>
    The `join` operator is currently in preview. To try it out, [contact Axiom](https://axiom.co/contact).

    The preview of the `join` operator works with an upper limit of 5,000 events on the left side of the join and 50,000 on the right side of the join.
</Note>

## Kinds of join

The kinds of join and their typical use cases are the following:

- `inner` (default): Returns rows where the join conditions exist in both tables. All matching rows from the right table are included for each matching row in the left table. Useful to retain all matches without limiting duplicates.
- `innerunique`:  Matches rows from both tables where the join conditions exist in both. For each row in the left table, only the first matching row from the right table is returned. Optimized for performance when duplicate matching rows on the right table are irrelevant.
- `leftouter`:  Returns all rows from the left table. If a match exists in the right table, the matching rows are included; otherwise, columns from the right table are `null`. Retains all data from the left table, enriching it with matching data from the right table.
- `rightouter`: Returns all rows from the right table. If a match exists in the left table, the matching rows are included; otherwise, columns from the left table are `null`. Retains all data from the right table, enriching it with matching data from the left table.
- `fullouter`: Returns all rows from both tables. Matching rows are combined, while non-matching rows from either table are padded with `null` values. Combines both tables while retaining unmatched rows from both sides.
- `leftanti`: Returns rows from the left table that have no matches in the right table. Identifies rows in the left table that do not have corresponding entries in the right table.
- `rightanti`: Returns rows from the right table that have no matches in the left table. Identifies rows in the right table that do not have corresponding entries in the left table.
- `leftsemi`: Returns rows from the left table that have at least one match in the right table. Only columns from the left table are included. Filters rows in the left table based on existence in the right table.
- `rightsemi`: Returns rows from the right table that have at least one match in the left table. Only columns from the right table are included. Filters rows in the right table based on existence in the left table.

<Note>
    The preview of the `join` operator currently only supports `inner` join. Support for other kinds of join is coming soon.
</Note>

### Summary of kinds of join

| Kind of join      | Behavior                                                          | Matches returned           |
|--------------------|-----------------------------------------------------------------------|--------------------------------|
| `inner`            | All matches between left and right tables                            | Multiple matches allowed       |
| `innerunique`      | First match for each row in the left table                            | Only unique matches            |
| `leftouter`        | All rows from the left, with matching rows from the right or `null`  | Left-dominant                  |
| `rightouter`       | All rows from the right, with matching rows from the left or `null`  | Right-dominant                 |
| `fullouter`        | All rows from both tables, with unmatched rows padded with `null`    | Complete join                  |
| `leftanti`         | Rows in the left table with no matches in the right table            | No matches                     |
| `rightanti`        | Rows in the right table with no matches in the left table            | No matches                     |
| `leftsemi`         | Rows in the left table with at least one match in the right table    | Matching rows (left table only)|
| `rightsemi`        | Rows in the right table with at least one match in the left table    | Matching rows (right table only)|

### Choose the right kind of join

- Use `inner` for standard joins where you need all matches.
- Use `leftouter` or `rightouter` when you need to retain all rows from one table.
- Use `leftanti` or `rightanti` to find rows that do not match.
- Use `fullouter` for complete combinations of both tables.
- Use `leftsemi` or `rightsemi` to filter rows based on existence in another table.

## For users of other query languages

If you come from other query languages, this section explains how to adjust your existing queries to achieve the same results in APL.

<AccordionGroup>
<Accordion title="Splunk SPL users">

The `join` operator in APL works similarly to the `join` command in Splunk SPL. However, APL provides additional flexibility by supporting various join types (e.g., `inner`, `outer`, `leftouter`). Splunk uses a single default join type.

<CodeGroup>
```sql Splunk example
index=logs | join type=inner [search index=traces]
```

```kusto APL equivalent
['sample-http-logs']
| join kind=inner ['otel-demo-traces'] on $left.id == $right.trace_id
```
</CodeGroup>

</Accordion>
<Accordion title="ANSI SQL users">

The `join` operator in APL resembles SQL joins but uses distinct syntax. SQL uses `FROM` and `ON` clauses, whereas APL uses the `join` operator with explicit `kind` and `on` clauses.

<CodeGroup>
```sql SQL example
SELECT *
FROM logs
JOIN traces
ON logs.id = traces.trace_id
```

```kusto APL equivalent
['sample-http-logs']
| join kind=inner ['otel-demo-traces'] on $left.id == $right.trace_id
```
</CodeGroup>

</Accordion>
</AccordionGroup>

## Usage

### Syntax

```kusto
LeftDataset
| join kind=KindOfJoin RightDataset on Conditions
```

### Parameters

- `LeftDataset`: The first dataset, also known as the outer table or the left side of the join. If you expect one of the datasets to contain consistently less data than the other, specify the smaller dataset as the left side of the join.
- `RightDataset`: The second dataset, also known as the inner table or the right side of the join.
- `KindOfJoin`: Optionally, the [kind of join](#kinds-of-join) to perform. The only supported value and the default is `inner`.
- `Conditions`: The conditions for matching rows. The conditions determine how Axiom matches rows from the `LeftDataset` with rows from the `RightDataset`.
    - To join datasets on a field that has the same name in the two datasets, simply use the field name. For example, `on id`.
    - To join datasets on a field that has different names in the two datasets, define the two field names in an equality expression such as `on $left.id == $right.trace_id`.
    - The two sides of the equality expression must have the same data type.
    - You can use expressions in the join conditions. For example, to compare two fields of different data types, use `on $left.id_string == tostring($right.trace_id_int)`.
    - You can define multiple join conditions. To separate conditions, use commas (`,`). Donâ€™t use `and`. For example, `on $left.id == $right.trace_id, $left.span == $right.span_id`.

### Returns

The `join` operator returns a new table containing rows that match the specified join condition. The columns from the left and right tables are included, prefixed with `$left.` and `$right.` to differentiate overlapping names.

## Use case examples

<Tabs>
<Tab title="Log analysis">

Join HTTP logs with trace data to correlate user activity with performance metrics.

**Query**

```kusto
['otel-demo-logs']
| join ['otel-demo-traces'] on span_id
```

**Output**

| $left._time | $left.span_id  | $right.trace_id | $right.duration |
|-------------|-----------|----------------|-----------------|
| 2024-12-01  | user123   | trace123       | 500ms           |

This query links user activity in HTTP logs to trace data to investigate performance issues.

</Tab>
<Tab title="OpenTelemetry traces">

Correlate service spans with HTTP logs to identify dependencies between services.

**Query**

```kusto
['otel-demo-traces']
| join kind=inner (['sample-http-logs']) on $left.trace_id == $right.id
```

**Output**

| $left.trace_id | $left.['service.name'] | $right.uri    |
|----------------|--------------------|--------------|
| trace123       | frontend           | /api/orders  |

This query reveals how service traces map to specific HTTP endpoints.

</Tab>
</Tabs>

## List of related operators

- [union](/apl/tabular-operators/union-operator): Combines rows from multiple tables without requiring a matching condition.
- [where](/apl/tabular-operators/where-operator): Filters rows based on conditions, often used with `join` for more precise results.