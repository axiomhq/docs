---
title: series_min
description: 'This page explains how to use the series_min function in APL.'
---

The `series_min` function compares two numeric arrays element by element and returns a new array. Each position in the result contains the minimum value between the corresponding elements from the two input arrays.

You use `series_min` when you want to create a lower bound from multiple series, combine baseline metrics with actual values while keeping the smaller value, or merge data from different sources by selecting the lower value at each point. For example, you can compare response times across different servers and keep the lower value at each time point, or create minimum thresholds from multiple sources.

## For users of other query languages

If you come from other query languages, this section explains how to adjust your existing queries to achieve the same results in APL.

<AccordionGroup>
<Accordion title="Splunk SPL users">

In Splunk SPL, element-wise minimum comparisons typically require custom logic with `eval` or `foreach`. In contrast, APL provides the specialized `series_min` function to directly compare arrays element by element and return the minimum values.

<CodeGroup>
```sql Splunk example
... | timechart avg(latency) as latency1, avg(latency_backup) as latency2
| eval min_latency = if(latency1 < latency2, latency1, latency2)
```

```kusto APL equivalent
['sample-http-logs']
| make-series primary = avg(req_duration_ms), backup = avg(req_duration_ms) on _time step 1m
| extend min_values = series_min(primary, backup)
```

</CodeGroup>

</Accordion>
<Accordion title="ANSI SQL users">

In ANSI SQL, you use the `LEAST()` function to compare scalar values. To compare sequences element-wise, you need window functions or complex joins. In APL, `series_min` simplifies this by applying the minimum operation across arrays in a single step.

<CodeGroup>
```sql SQL example
SELECT _time,
       LEAST(t1.req_duration_ms, t2.req_duration_ms) AS min_duration
FROM logs t1
JOIN logs t2
  ON t1._time = t2._time
```

```kusto APL equivalent
['sample-http-logs']
| make-series series1 = avg(req_duration_ms), series2 = avg(req_duration_ms) on _time step 1m
| extend min_series = series_min(series1, series2)
```

</CodeGroup>

</Accordion>
</AccordionGroup>

## Usage

### Syntax

```kusto
series_min(array1, array2)
```

### Parameters

| Parameter | Type  | Description                                                                |
| --------- | ----- | -------------------------------------------------------------------------- |
| `array1`  | array | The first array of numeric values.                                         |
| `array2`  | array | The second array of numeric values. Must have the same length as `array1`. |

### Returns

An array of numeric values. Each element is the minimum of the corresponding elements from `array1` and `array2`.

## Use case examples

<Tabs>
<Tab title="Log analysis">

You want to create a lower bound by comparing request durations across two different cities and keeping the lower value at each time point.

**Query**

```kusto
['sample-http-logs']
| take 50
| make-series london_avg = avgif(req_duration_ms, ['geo.city'] == 'London'),
             paris_avg = avgif(req_duration_ms, ['geo.city'] == 'Paris')
             on _time step 1h
| extend min_duration = series_min(london_avg, paris_avg)
```

[Run in Playground](https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22%5B'sample-http-logs'%5D%20%7C%20take%2050%20%7C%20make-series%20london_avg%20%3D%20avgif(req_duration_ms%2C%20%5B'geo.city'%5D%20%3D%3D%20'London')%2C%20paris_avg%20%3D%20avgif(req_duration_ms%2C%20%5B'geo.city'%5D%20%3D%3D%20'Paris')%20on%20_time%20step%201h%20%7C%20extend%20min_duration%20%3D%20series_min(london_avg%2C%20paris_avg)%22%7D)

**Output**

| london_avg      | paris_avg       | min_duration    |
| --------------- | --------------- | --------------- |
| [120, 150, 100] | [180, 130, 190] | [120, 130, 100] |

This query compares response times between two cities and creates a series containing the lower value at each time point.

</Tab>
<Tab title="OpenTelemetry traces">

You want to compare HTTP status codes between two services and keep the lower status code at each time point.

**Query**

```kusto
['otel-demo-traces']
| where isnotnull(['attributes.http.status_code'])
| make-series frontend_status = avgif(tolong(['attributes.http.status_code']), ['service.name'] == 'frontend'),
             backend_status = avgif(tolong(['attributes.http.status_code']), ['service.name'] == 'checkoutservice')
             on _time step 5m
| extend min_status = series_min(frontend_status, backend_status)
```

[Run in Playground](https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22%5B'otel-demo-traces'%5D%20%7C%20where%20isnotnull(%5B'attributes.http.status_code'%5D)%20%7C%20make-series%20frontend_status%20%3D%20avgif(tolong(%5B'attributes.http.status_code'%5D)%2C%20%5B'service.name'%5D%20%3D%3D%20'frontend')%2C%20backend_status%20%3D%20avgif(tolong(%5B'attributes.http.status_code'%5D)%2C%20%5B'service.name'%5D%20%3D%3D%20'checkoutservice')%20on%20_time%20step%205m%20%7C%20extend%20min_status%20%3D%20series_min(frontend_status%2C%20backend_status)%22%7D)

**Output**

| frontend_status     | backend_status      | min_status          |
| ------------------- | ------------------- | ------------------- |
| [200.0, 204.5, 200.0] | [201.0, 200.0, 205.0] | [200.0, 200.0, 200.0] |

This query compares status codes across services and creates a series with the minimum status code at each time interval.

</Tab>
<Tab title="Security logs">

You want to track the minimum count between successful and failed requests at each time point to identify which type has less traffic.

**Query**

```kusto
['sample-http-logs']
| take 50
| make-series success_count = countif(status == '200'),
             failure_count = countif(status != '200')
             on _time step 1h
| extend min_count = series_min(success_count, failure_count)
```

[Run in Playground](https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22%5B'sample-http-logs'%5D%20%7C%20take%2050%20%7C%20make-series%20success_count%20%3D%20countif(status%20%3D%3D%20'200')%2C%20failure_count%20%3D%20countif(status%20!%3D%20'200')%20on%20_time%20step%201h%20%7C%20extend%20min_count%20%3D%20series_min(success_count%2C%20failure_count)%22%7D)

**Output**

| success_count  | failure_count | min_count    |
| -------------- | ------------- | ------------ |
| [300, 280, 310] | [10, 290, 15] | [10, 280, 15] |

This query compares success and failure counts and returns the lower value at each time point, helping you identify the minority traffic pattern.

</Tab>
</Tabs>

## List of related functions

- [series_max](/apl/scalar-functions/time-series/series-max): Compares two arrays and returns the maximum value at each position.
- [series_less](/apl/scalar-functions/time-series/series-less): Compares two arrays and returns `true` where elements in the first array are less than the second.
- [series_greater](/apl/scalar-functions/time-series/series-greater): Compares two arrays and returns `true` where the first array element is greater than the second.
- [min](/apl/aggregation-function/min): Aggregation function that returns the minimum value across grouped records.
