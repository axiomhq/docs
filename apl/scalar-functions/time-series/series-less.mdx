---
title: series_less
description: 'This page explains how to use the series_less function in APL.'
---

The `series_less` function compares two numeric arrays element by element and returns a Boolean array. Each position in the result contains `true` if the element in the first array is less than the corresponding element in the second array, and `false` otherwise.

You use `series_less` when you want to evaluate trends across sequences of numeric values. It is especially useful in time series analysis, anomaly detection, or comparing metrics side by side. For example, you can check if response times are decreasing compared to a baseline or if one service consistently performs faster than another.

## For users of other query languages

If you come from other query languages, this section explains how to adjust your existing queries to achieve the same results in APL.

<AccordionGroup>
<Accordion title="Splunk SPL users">

In Splunk SPL, comparisons across series typically rely on `eval` with conditional expressions or custom logic in combination with `timechart`. In contrast, APL provides specialized `series_*` functions like `series_less` to directly compare arrays element by element.

<CodeGroup>
```sql Splunk example
... | timechart avg(req_duration_ms) as avg_dur 
| eval faster = if(avg_dur < 200, true, false)
````

```kusto APL equivalent
['sample-http-logs']
| make-series avg(req_duration_ms) on _time step 1m
| extend is_less = series_less(avg_req_duration_ms, array_concat(dynamic([200])))
```

</CodeGroup>

</Accordion>
<Accordion title="ANSI SQL users">

In ANSI SQL, you normally compare scalar values rather than arrays. To compare sequences, you need to join tables with offsets or use window functions. In APL, `series_less` simplifies this by applying the comparison across arrays in a single step.

<CodeGroup>
```sql SQL example
SELECT t1._time,
       CASE WHEN t1.req_duration_ms < t2.req_duration_ms THEN true ELSE false END AS is_less
FROM logs t1
JOIN logs t2
  ON t1._time = t2._time
```

```kusto APL equivalent
['sample-http-logs']
| make-series avg(req_duration_ms) on _time step 1m
| extend compare = series_less(avg_req_duration_ms, avg_req_duration_ms[1:])
```

</CodeGroup>

</Accordion>
</AccordionGroup>

## Usage

### Syntax

```kusto
series_less(array1, array2)
```

### Parameters

| Parameter | Type  | Description                                                                |
| --------- | ----- | -------------------------------------------------------------------------- |
| `array1`  | array | The first array of numeric values.                                         |
| `array2`  | array | The second array of numeric values. Must have the same length as `array1`. |

### Returns

An array of Boolean values. Each element is `true` if the corresponding element in `array1` is less than the element in `array2`, otherwise `false`.

## Use case examples

<Tabs>
<Tab title="Log analysis">

You want to check whether the average request duration in each city is less than the overall global average.

**Query**

```kusto
['sample-http-logs']
| make-series city_avg = avg(req_duration_ms) on _time step 1h by geo.city
| extend global_avg = series_avg(city_avg)
| extend is_less = series_less(city_avg, global_avg)
```

\[Run in Playground]\([https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22\['sample-http-logs](https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22['sample-http-logs)'] | make-series city\_avg = avg(req\_duration\_ms) on \_time step 1h by geo.city | extend global\_avg = series\_avg(city\_avg) | extend is\_less = series\_less(city\_avg, global\_avg)%22%7D)

**Output**

| geo.city | city\_avg        | global\_avg      | is\_less               |
| -------- | ---------------- | ---------------- | ---------------------- |
| London   | \[120, 90, 100]  | \[150, 150, 150] | \[true, true, true]    |
| Paris    | \[180, 200, 190] | \[150, 150, 150] | \[false, false, false] |

This query shows whether each cityâ€™s request duration is below the global average at each time step.

</Tab>
<Tab title="OpenTelemetry traces">

You want to verify if the duration of each span is less than the corresponding duration of the previous span for the same service.

**Query**

```kusto
['otel-demo-traces']
| make-series span_durations = avg(duration) on _time step 5m by ['service.name']
| extend shifted = series_shift(span_durations, 1)
| extend decreasing = series_less(span_durations, shifted)
```

\[Run in Playground]\([https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22\['otel-demo-traces](https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22['otel-demo-traces)'] | make-series span\_durations = avg(duration) on \_time step 5m by \['service.name'] | extend shifted = series\_shift(span\_durations, 1) | extend decreasing = series\_less(span\_durations, shifted)%22%7D)

**Output**

| service.name | span\_durations      | shifted              | decreasing           |
| ------------ | -------------------- | -------------------- | -------------------- |
| frontend     | \[50ms, 40ms, 45ms]  | \[null, 50ms, 40ms]  | \[null, true, false] |
| cartservice  | \[100ms, 95ms, 90ms] | \[null, 100ms, 95ms] | \[null, true, true]  |

This query identifies whether spans are becoming shorter compared to the previous time bucket.

</Tab>
<Tab title="Security logs">

You want to detect if failed requests in each country are consistently less than successful requests.

**Query**

```kusto
['sample-http-logs']
| summarize success = countif(status == '200'), failure = countif(status != '200') by geo.country, bin(_time, 1h)
| make-series success_series = avg(success), failure_series = avg(failure) on _time step 1h by geo.country
| extend failures_less = series_less(failure_series, success_series)
```

\[Run in Playground]\([https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22\['sample-http-logs](https://play.axiom.co/axiom-play-qf1k/query?initForm=%7B%22apl%22%3A%22['sample-http-logs)'] | summarize success = countif(status == '200'), failure = countif(status != '200') by geo.country, bin(\_time, 1h) | make-series success\_series = avg(success), failure\_series = avg(failure) on \_time step 1h by geo.country | extend failures\_less = series\_less(failure\_series, success\_series)%22%7D)

**Output**

| geo.country | success\_series  | failure\_series | failures\_less      |
| ----------- | ---------------- | --------------- | ------------------- |
| US          | \[300, 280, 310] | \[10, 20, 15]   | \[true, true, true] |
| UK          | \[150, 140, 160] | \[20, 25, 30]   | \[true, true, true] |

This query checks whether failures stay consistently lower than successful requests across time intervals.

</Tab>
</Tabs>

## List of related functions

* [series\_greater](/apl/array-functions/series_greater): Returns `true` when elements in the first array are greater than in the second array.
* [series\_equals](/apl/array-functions/series_equals): Returns `true` when elements in both arrays are equal.
* [series\_not\_equals](/apl/array-functions/series_not_equals): Returns `true` when elements in both arrays are different.
* [series\_less\_equals](/apl/array-functions/series_less_equals): Returns `true` when elements in the first array are less than or equal to the second array.
* [series\_greater\_equals](/apl/array-functions/series_greater_equals): Returns `true` when elements in the first array are greater than or equal to the second array.
